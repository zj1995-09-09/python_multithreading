# encoding: utf-8
# @author: MrZhou
# @file: __并发编程之多进程理论.py
# @time: 2023/2/22 16:36
# @desc:
多道技术：
1.产生背景：针对单核，实现并发
1、现在的主机一般是多核，那么每个核都会利用多道技术
有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
cpu中的任意一个，具体由操作系统调度算法决定

2、空间上复用，如内存中同时有多道程序
3、时间上复：复用一个cpu的时间片
强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样
才能保证下次切换回来时，能基于上次切走的位置继续运行


进程：正在进行的一个过程或者说一个任务，而负责执行任务是CPU
进程与程序的区别
程序仅仅只是一堆代码，而进程指的是程序的运行过程

同一个程序执行两次，那也是两个进程比如打开暴风影音，虽然都是同一个软件，但是一个可以播放体育世界，一个可以播放电影世界。
一并发：是伪并行，看起来是同时运行。单个CPU+多道技术实现并发 并行也属于并发
二并行：同时运行，只有具备多个cpu才能实现并行

所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。
多道技术概念：内存中同时存入多道(多个)程序，CPU从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样
一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发
以此来区分多处理器操作系统 的真正硬件并行


同步
发出一个功能调用时，在没有得到结果之前，该调用就不会返回 绝大多数函数都是同步调用
但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务

#举例：
#1. multiprocessing.Pool下的apply #发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束
#2. concurrent.futures.ProcessPoolExecutor().submit(func,).result()
#3. concurrent.futures.ThreadPoolExecutor().submit(func,).result()

异步：
概念与同步相对，当一个异步功能调用发出后，调用者不能立刻得到结果。
。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低
（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。
如果是使用通知的方式，效率则很高，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。
#举例：
#1. multiprocessing.Pool().apply_async() #发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）。
#2. concurrent.futures.ProcessPoolExecutor(3).submit(func,)
#3. concurrent.futures.ThreadPoolExecutor(3).submit(func,)

阻塞：
#阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。
# 函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。
# 对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。

# 非阻塞：
# 与阻塞相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程
#
# 同步与异步针对的是函数/任务的调用方式，同步就是当一个进程发起一个一个函数(任务)调用的时候
# 一直等到函数完成，而进程继续处于激活状态
# 而异步情况下是当一个进程发起一个函数(任务)调用时，不会等函数返回，而是继续往下执行，当函数返回的时候
# 通过状态、通知、事件等方式通知进程任务完成
#
# 阻塞与非阻塞针对的是进程或线程，阻塞是当请求不能满足的时候就将进程挂起
# 而非阻塞则不会阻塞当前进程
#
#
# 进程的创建
# 1、系统初始化 查看进程linux中用ps命令，Windows中用任务管理器
# 前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程称为守护进程
# 如电子邮件、web页面、新闻、打印
# 2、一个进程在运行过程中开启了子进程 如Nginx开启多线程
# 3、用户的交互请求，而创建一个新进程 如用户双击暴风影音
# 4、一个批处理作业的初始化 只在大型机的批处理系统中应用
#
# 无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建
# 1、Unix系统 fork
# fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）
# 2、windows
# create process 既处理进程的创建，也负责把正确的程序装入新进程
#
# 关于创建的子进程 Unix和Windows
#
# 1、相同的是 进程创建后，父进程和子进程有各自不同的地址空间
# 　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，
# 、提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。
#
# 进程的终止
# 1、正常退出
# （自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）
# 2. 出错退出（自愿，python a.py中a.py不存在）
# 3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）
# 4.
# 被其他进程杀死（非自愿，如kill - 9）
#
# 进程层次结构
#
# 1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，
# 这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员
# 2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，
# 是在创建进程时，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。
#
#
# 进程的状态
# 运行 阻塞 就绪
# 1、进程为等待输入而阻塞
# 2、调度程序选择另一个进程
# 3、调度程序选择这个进程
# 4、出现有效输入
#
# 进程并发实现
# 在于硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来 为此操作系统维护进程表 process table
# 每个进程占用一个进程表项